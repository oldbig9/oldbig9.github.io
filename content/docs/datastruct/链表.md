---
weight: 100
title: "链表"
description: ""
icon: "article"
date: "2025-10-26T13:03:40+08:00"
lastmod: "2025-10-26T13:03:40+08:00"
draft: true
toc: true
tags:
- 数据结构
categories:
- tech
series:
---

链表是一种线性数据结构，元素内存分配是不连续的。

查找元素时间复杂度为O(n),插入和删除元素时间复杂度因位置而不同

## 链表golang实现

```go
package main

import "fmt"

func main() {
	s := []int{1, 2, 3, 4, 5}
	head := &ListNode{Val: s[0]}
	cur := head
	for i, v := range s {
		if i == 0 {
			continue
		}
		cur.Next = &ListNode{Val: v}
		cur = cur.Next
	}

	head.AddAfterTail(&ListNode{Val: 6})
	head.AddBeforeHead(&ListNode{Val: 11})
	head.Add(&ListNode{Val: 10}, 0)
	fmt.Println(head.List())

}

// 单向链表
type ListNode struct {
	Val  int
	Next *ListNode
}

// 输出链表所有元素
func (head *ListNode) List() []int {
	node := head
	res := make([]int, 0)
	for node != nil {
		res = append(res, node.Val)
		node = node.Next
	}

	return res
}

// 查找链表元素
func (head *ListNode) Find(target int) bool {
	node := head
	for node != nil {
		if node.Val == target {
			return true
		}
		node = node.Next
	}

	return false
}

// 插入元素
func (head *ListNode) Add(node *ListNode, index int) bool {
	if index == 0 {
		head.AddBeforeHead(node)
		return true
	}
	tmp := &ListNode{Next: head}
	cur := tmp
	for i := 0; i < index && cur != nil; i++ {
		cur = cur.Next
	}

	if cur == nil {
		return false
	}

	newNext := &ListNode{Val: node.Val, Next: cur.Next}
	cur.Next = newNext
	return true
}

// 头部插入元素
func (head *ListNode) AddBeforeHead(node *ListNode) {
	node.Next = &ListNode{Val: head.Val, Next: head.Next}
	head.Val = node.Val
	head.Next = node.Next
}

// 尾部插入元素
func (head *ListNode) AddAfterTail(node *ListNode) {
	cur := head
	for {
		if cur.Next == nil {
			cur.Next = node
			break
		}
		cur = cur.Next
	}
}

// 删除元素
func (head *ListNode) Remove(target int) bool {
	if head.Val == target {
		head.Val = head.Next.Val
		head.Next = head.Next.Next
		return true
	}
	cur := head
	for cur.Next != nil {
		if cur.Next.Val == target {
			if cur.Next.Next == nil {
				cur.Next = nil
				return true
			} else {
				cur.Next = cur.Next.Next
			}
		}
		cur = cur.Next
	}

	return false
}

// 链表反转
func (head *ListNode) Reverse() *ListNode {
	var prev *ListNode
	cur := head

	for cur != nil {
		next := cur.Next
		cur.Next = prev
		prev = cur
		cur = next
	}

	return prev
}

```
